using Google.Protobuf;
using Proto;

namespace Hiero.Implementation;

internal sealed class Invoice : IInvoice
{
    private readonly TransactionId _txId;
    private readonly string _memo;
    private readonly ReadOnlyMemory<byte> _txBytes;
    private readonly int _prefixTrimLimit;
    private readonly Dictionary<ByteString, SignaturePair> _signatures;
    private readonly CancellationToken _cancellationToken;

    TransactionId IInvoice.TransactionId => _txId;
    string IInvoice.Memo => _memo;
    ReadOnlyMemory<byte> IInvoice.TransactionBytes => _txBytes;
    int IInvoice.MinimumDesiredPrefixSize => _prefixTrimLimit;
    CancellationToken IInvoice.CancellationToken => _cancellationToken;

    internal Invoice(TransactionBody transactionBody, int prefixTrimLimit, CancellationToken cancellationToken)
    {
        _txId = transactionBody.TransactionID.AsTxId();
        _memo = transactionBody.Memo;
        _txBytes = transactionBody.ToByteArray();
        _prefixTrimLimit = prefixTrimLimit;
        _memo = transactionBody.Memo;
        _cancellationToken = cancellationToken;
        _signatures = [];
    }
    internal Invoice(ReadOnlyMemory<byte> transactionBodyBytes, int prefixTrimLimit, CancellationToken cancellationToken)
    {
        var transactionBody = TransactionBody.Parser.ParseFrom(transactionBodyBytes.Span);
        _txId = transactionBody.TransactionID.AsTxId();
        _memo = transactionBody.Memo;
        _txBytes = transactionBodyBytes;
        _prefixTrimLimit = prefixTrimLimit;
        _signatures = [];
    }
    void IInvoice.AddSignature(KeyType type, ReadOnlyMemory<byte> publicPrefix, ReadOnlyMemory<byte> signature)
    {
        var key = ByteString.CopyFrom(publicPrefix.Span);
        var value = ByteString.CopyFrom(signature.Span);
        var pair = new SignaturePair();
        switch (type)
        {
            case KeyType.Ed25519:
                pair.Ed25519 = value;
                break;
            case KeyType.ECDSASecp256K1:
                pair.ECDSASecp256K1 = value;
                break;
            case KeyType.Contract:
                pair.Contract = value;
                break;
        }
        if (_signatures.TryGetValue(key, out SignaturePair? existing))
        {
            if (!pair.Equals(existing))
            {
                throw new ArgumentException("Signature with Duplicate Prefix Identifier was provided, but did not have an Identical Signature.");
            }
        }
        else
        {
            _signatures.Add(key, pair);
        }
    }
    internal SignedTransaction GenerateSignedTransactionFromSignatures(bool failIfNoSignatures)
    {
        var sigMap = TryGenerateMapFromCollectedSignatures();
        if (sigMap is null)
        {
            if (failIfNoSignatures)
            {
                throw new InvalidOperationException("A transaction or query requires at least one signature, sometimes more.  None were generated by the provided signatories, did you forget to assign a non-scheduling Signatory to the context, transaction or query?");
            }
        }
        return new SignedTransaction
        {
            BodyBytes = ByteString.CopyFrom(_txBytes.Span),
            SigMap = sigMap
        };
    }
    internal SignatureMap? TryGenerateMapFromCollectedSignatures()
    {
        var count = _signatures.Count;
        if (count == 0)
        {
            return null;
        }
        var map = new SignatureMap();
        if (count == 1 && _prefixTrimLimit < 1)
        {
            map.SigPair.Add(_signatures.Values.First());
        }
        else
        {
            var list = _signatures.ToArray();
            var keys = new byte[count][];
            for (var length = Math.Max(1, _prefixTrimLimit); true; length++)
            {
                var unique = true;
                for (var i = 0; unique && i < count; i++)
                {
                    var key = keys[i] = list[i].Key.Memory.Slice(0, Math.Min(list[i].Key.Length, length)).ToArray();
                    for (var j = 0; j < i; j++)
                    {
                        if (Enumerable.SequenceEqual(key, keys[j]))
                        {
                            unique = false;
                            break;
                        }
                    }
                }
                if (unique)
                {
                    break;
                }
            }
            for (var i = 0; i < count; i++)
            {
                var sig = list[i].Value;
                sig.PubKeyPrefix = ByteString.CopyFrom(keys[i]);
                map.SigPair.Add(sig);
            }
        }
        return map.SigPair.Count > 0 ? map : null;
    }
}